
/*
 * Copyright (C) 2021 Freedom of Form Foundation, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License, version 2 (GPLv2) as published by the Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License, version 2 (GPLv2) for more details.
 * 
 * You should have received a copy of the GNU General Public License, version 2 (GPLv2)
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

using System;

namespace FreedomOfFormFoundation.AnatomyEngine.Calculus
{
	/// <summary>
	/// ContinuousMapExtensions contains generic ContinuousMap functionality that does not need any "inside knowledge"
	/// of the map implementations. All ContinuousMap implementations have these features.
	/// </summary>
	public static class ContinuousMapExtensions
	{
		/// <summary>
		/// Composes a ContinuousMap generated by taking the output of this map and sending it to the provided map.
		/// The output is another ContinuousMap, so a chain of maps can be described with .Then().Then().Then()...
		///
		/// This should be much more convenient than the ComposedMap constructor, because the parameterized types
		/// should be completely autodeduced, getting them out of the middle of the expression. The resulting
		/// ComposedMap is lightweight (it is one pointer to each map), so it's okay to use it once and throw it
		/// away (by using left.Then(right).GetValueAt(x) in the middle of an expression).
		/// </summary>
		/// <param name="left">This. Map that should receive input values. Nonnull.</param>
		/// <param name="right">Map to receive values from this and return values in the composed map. Nonnull.</param>
		/// <typeparam name="TIn">Input type of This, and of the composed map.</typeparam>
		/// <typeparam name="TIntermediate">Output type of This and input type of the argument.</typeparam>
		/// <typeparam name="TOut">Output type of the argument map and of the composed map.</typeparam>
		/// <returns>A ContinousMap (a ComposedMap, specifically) that acts like "left, then right".</returns>
		public static ComposedMap<TIn, TIntermediate, TOut> Then<TIn, TIntermediate, TOut>(this ContinuousMap<TIn,
			TIntermediate> left, ContinuousMap<TIntermediate, TOut> right)
		{
			return new ComposedMap<TIn, TIntermediate, TOut>(left, right);
		}

		/// <summary>
		/// Composes a ContinuousMap generated by taking the output of this map and sending it to a map created
		/// with a GetValueAt function implemented from the provided delegate (which can be a lambda). The
		/// output is another ContinousMap, so a chain of maps can be described with .Then().Then().Then()...
		/// </summary>
		/// <param name="left">This. Map that should receive input values. Nonnull.</param>
		/// <param name="right">Function taking values from this and return values in the composed map. Nonnull.</param>
		/// <typeparam name="TIn">Input type of This, and of the composed map.</typeparam>
		/// <typeparam name="TIntermediate">Output type of This and input type of the argument.</typeparam>
		/// <typeparam name="TOut">Output type of the argument function and of the composed map.</typeparam>
		/// <returns>A ContinousMap (a ComposedMap, specifically) that acts like "left, then right".</returns>
		public static ComposedMap<TIn, TIntermediate, TOut> Then<TIn, TIntermediate, TOut>(this ContinuousMap<TIn,
			TIntermediate> left, Func<TIntermediate, TOut> right)
		{
			return new ComposedMap<TIn, TIntermediate, TOut>(left,
				new FunctionBackedContinuousMap<TIntermediate, TOut>(right));
		}

		/// <summary>
		/// Composes a ContinuousMap generated by taking the output of the provided map and feeding it into this
		/// map. It is the opposite of "then". It is mathematically equivalent to <c>this ∘ param</c>.
		///
		/// <see cref="Then{TIn,TIntermediate,TOut}"/> for more information on the performance of this method.
		/// </summary>
		/// <param name="outer">This. Map that should receive intermediate values and return final values. Nonnull.</param>
		/// <param name="inner">Map to receive values from GetValue calls and pass them to this. Nonnull.</param>
		/// <typeparam name="TIn">Input type of parameter, and of the composed map.</typeparam>
		/// <typeparam name="TIntermediate">Output type of parameter and input type of this.</typeparam>
		/// <typeparam name="TOut">Output type of the this and of the composed map.</typeparam>
		/// <returns>A ContinousMap (a ComposedMap, specifically) that acts like "right, then left".</returns>
		public static ComposedMap<TIn, TIntermediate, TOut> Compose<TIn, TIntermediate, TOut>(
			this ContinuousMap<TIntermediate,TOut> outer,
			ContinuousMap<TIn, TIntermediate> inner)
		{
			return new ComposedMap<TIn, TIntermediate, TOut>(inner, outer);
		}

		/// <summary>
		/// Composes a ContinuousMap implementing GetValueAt by first executing the provided delegate, then returning
		/// GetValueAt from this map. It is the opposite of "then". It is mathematically equivalent
		/// to <c>this ∘ param</c>.
		///
		/// <see cref="Then{TIn,TIntermediate,TOut}"/> for more information on the performance of this method.
		/// </summary>
		/// <param name="outer">This. Map that should receive intermediate values and return final values. Nonnull.</param>
		/// <param name="inner">Func to receive values from GetValue calls and pass them to this. Nonnull.</param>
		/// <typeparam name="TIn">Input type of parameter, and of the composed map.</typeparam>
		/// <typeparam name="TIntermediate">Output type of parameter and input type of this.</typeparam>
		/// <typeparam name="TOut">Output type of the this and of the composed map.</typeparam>
		/// <returns>A ContinousMap (a ComposedMap, specifically) that acts like "right, then left".</returns>
		public static ComposedMap<TIn, TIntermediate, TOut> Compose<TIn, TIntermediate, TOut>(
			this ContinuousMap<TIntermediate, TOut> outer,
			Func<TIn, TIntermediate> inner)
		{
			return new ComposedMap<TIn, TIntermediate, TOut>(
				new FunctionBackedContinuousMap<TIn, TIntermediate>(inner),
				outer);
		}
	}
}
