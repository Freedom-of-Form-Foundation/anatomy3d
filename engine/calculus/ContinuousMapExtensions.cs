/*
 * Copyright (C) 2021 Freedom of Form Foundation, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License, version 2 (GPLv2) as published by the Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License, version 2 (GPLv2) for more details.
 * 
 * You should have received a copy of the GNU General Public License, version 2 (GPLv2)
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

﻿using System.Globalization;

namespace FreedomOfFormFoundation.AnatomyEngine.Calculus
{
	/// <summary>
	/// ContinuousMapExtensions contains generic ContinuousMap functionality that does not need any "inside knowledge"
	/// of the map implementations. All ContinuousMap implementations have these features.
	/// </summary>
	public static class ContinuousMapExtensions
	{
		/// <summary>
		/// Composes a ContinuousMap generated by taking the output of this map and sending it to the provided map.
		/// The output is another ContinuousMap, so a chain of maps can be described with .Then().Then().Then()...
		///
		/// This should be much more convenient than the ComposedMap constructor, because the parameterized types
		/// should be completely autodeduced, getting them out of the middle of the expression. The resulting
		/// ComposedMap is lightweight (it is one pointer to each map), so it's okay to use it once and throw it
		/// away (by using left.Then(right).GetValueAt(x) in the middle of an expression).
		/// </summary>
		/// <param name="left">This. Map that should receive input values. Nonnull.</param>
		/// <param name="right">Map to receive values from this and return values in the composed map. Nonnull.</param>
		/// <typeparam name="TIn">Input type of This, and of the composed map.</typeparam>
		/// <typeparam name="TIntermediate">Output type of This and input type of the argument.</typeparam>
		/// <typeparam name="TOut">Output type of the argument map and of the composed map.</typeparam>
		/// <returns></returns>
		public static ComposedMap<TIn, TIntermediate, TOut> Then<TIn, TIntermediate, TOut>(this ContinuousMap<TIn,
			TIntermediate> left, ContinuousMap<TIntermediate, TOut> right)
		{
			return new ComposedMap<TIn, TIntermediate, TOut>(left, right);
		}

		/// <summary>
		/// Composes a ContinuousMap generated by taking the output of the provided map and feeding it into this
		/// map. It is the opposite of "then". It is mathematically equivalent to <c>this ∘ param</c>.
		///
		/// <see cref="Then{TIn,TIntermediate,TOut}"/> for more information on the performance of this method.
		/// </summary>
		/// <param name="outer">This. Map that should receive intermediate values and return final values. Nonnull.</param>
		/// <param name="inner">Map to receive values from GetValue calls and pass them to this. Nonnull.</param>
		/// <typeparam name="TIn">Input type of parameter, and of the composed map.</typeparam>
		/// <typeparam name="TIntermediate">Output type of parameter and input type of this.</typeparam>
		/// <typeparam name="TOut">Output type of the this and of the composed map.</typeparam>
		/// <returns></returns>
		public static ComposedMap<TIn, TIntermediate, TOut> Compose<TIn, TIntermediate, TOut>(this ContinuousMap<TIntermediate,
			TOut> outer, ContinuousMap<TIn, TIntermediate> inner)
		{
			return new ComposedMap<TIn, TIntermediate, TOut>(inner, outer);
		}
	}
}
